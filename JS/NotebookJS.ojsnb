{
    "id": "2a0f571c-339f-49cc-9878-51aeface5b91",
    "files": [],
    "nodes": [
        {
            "id": "tmp-0",
            "name": "",
            "value": "## NOTEBOOK JAVASCRIPT - Acompanhando o curso da Udemy",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-1",
            "name": "",
            "value": "#### Prefácio - Sobre *console.log()* e *return*  \r\n\r\n&nbsp;&nbsp;Quando se insere um código em uma célula e solicita-se a sua execução, o Notebook executará **a célula**. A função console.log é chamada de *função side-effect*, o que significa que ela não executa ação alguma e gerando a saída \"undefined\".  \r\n&nbsp;&nbsp;Desta forma, se torna necessário para manter a boa utilização deste Notebook alterar o comando de visualização da tela *return*, conforme o seguinte exemplo:",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-2",
            "name": "",
            "value": "const a = 123\r\nreturn a",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-3",
            "name": "",
            "value": "---",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-4",
            "name": "",
            "value": "##### Aula 7",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-5",
            "name": "",
            "value": "- O Método \"console.log()\" é o método **log** do objeto **console**.\r\n- Quando a gente introduz um texto entre aspas dentro de um console.log, este texto é considerado um **valor literal**.\r\n- É possível exibir no terminal através do console.log números de forma literal **sem usar apas**.\r\n- Exibindo conjuntos de caracteres de forma literal no console.log, pode-se usar a vírgula para diferenciar conjuntos diferentes, e o terminal irá os exibir separados por um espaço. Strings ainda devem estar cercadas por aspas.\r\n- a função console.log() é considerada uma boa ferramenta para debug.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-6",
            "name": "",
            "value": "Exercício:",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-7",
            "name": "",
            "value": "return `Meu nome é \"Jade\". Estou aprendendo JavaScript às `+ 6 + ` da manhã.` // comentario",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-8",
            "name": "",
            "value": "#### Aula 8",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-9",
            "name": "",
            "value": "- Não é recomendado que se introduza muitos comentários dentro do código, e sim, que produza-se códigos de simples compreensão. ",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-10",
            "name": "",
            "value": "#### Aula 12 - JS + HTML",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-11",
            "name": "",
            "value": "    OBS: Esta aula utiliza mais de um arquivo, então o código de teste está na pasta 'Aula 12'.\r\n---\r\n    Notas:\r\n- Para startar um esqueleto básico para html, pode-se digitar '!' seguido da tecla Enter ou 'html:5' seguido da tecla Enter.\r\n- Dentro do console do Chrome, se eu desejar executar alguma linha de código introduzida, devo pressionar a tecla Enter.\r\n- o comando *alert* cria uma 'caixa' com uma mensagem no navegador, que \"trancará\" o resto do código até que o usuário pressione o botão 'ok'.\r\n- A quebra de linha dentro do console do Chrome é dada pelas teclas 'Shift'+'Enter'.\r\n- Dentro do console do Chrome, utilizar a seta \"pra cima\" mostra o último comando enviado.\r\n- O NodeJS **não contém** o comando *alert*. \r\n- É considerado boa prática não só não criar comandos JS na tag < script> como ter uma pasta onde estão estes arquivos, que vão ser referenciados na chamada do arquivo .js.\r\n",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-0",
            "name": "",
            "value": "#### Aula 13 - Variáveis com 'let'",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-1",
            "name": "",
            "value": "    Regras de criação de variáveis:\r\n- Não podemos criar variáveis com palavras reservadas\r\n- Variáveis precisam ter nomes significativos\r\n- Não podemos começar o nome de uma variável com números\r\n- O nome das variáveis não pode conter espaços ou traços\r\n- utilizamos *camelCase*\r\n- nomes de variáveis são *case sensitive*\r\n- Não podemos redeclarar variáveis;\r\n- **Não utilize var. Utilize let.**",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-2",
            "name": "",
            "value": "#### Aula 14 - Constantes com 'const'",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-3",
            "name": "",
            "value": "    Regras pra criação de constantes\r\n- Não podemos criar constantes com palavras reservadas\r\n- Constantes precisam ter nomes significativos\r\n- Não podemos começar o nome de uma constante com um número\r\n- Não podem contar espaços ou traços\r\n- Utilizamos camelCase\r\n- Case-sensitive\r\n- Não dá pra modificar o valor de uma constante\r\n- **Atenção**: quando reatribuimos o valor de uma variável, perdemos o seu valor original.\r\n- **Não utilize 'var', utilize 'const'.**\r\n- Não podemos inicializar constantes sem atribuir um valor a elas (já que elas não podem ser alteradas).\r\n- Prefira sempre usar const, a não ser que perceba que é preciso alterar o valor da variável.  \r\n- É considerada uma **boa prática de programação** chamar a função *typeof* sem parênteses para chamar o argumento\r\n    Exemplo: **console.log(typeof numero)** || console.log(typeof (numero))\r\n  \r\nO JavaScript é uma linguagem de *tipagem dinâmica*, ou seja: ao atribuir um valor a uma variável ou constante o JS supõe um tipo pré-definido pra esta variável ou constante,  \r\n  \r\n**console.log(typeof(variável))** retorna o tipo da variável",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-0",
            "name": "",
            "value": "#### Aula 17 - Primeira diferença entre 'var' e 'let'",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-1",
            "name": "",
            "value": "- Variáveis declaradas com *var* **podem ser redeclaradas**, enquanto variáveis declaradas com *let* **não podem ser redeclaradas**.\r\n- **ECMAScript** é uma padronização da linguagem JS criada pela empresa ECMA International; A versão ECMAScript de 2015 é chamada **ES6**\r\n- O comando 'let' foi introduzido na ES6.\r\n- É possível declarar pela primeira vez uma variável sem utilizar um comando de declaração, porém o JS interpreta que esta é uma **variável global**, ou seja, pode interferir no resto do seu código e portanto não é recomendado.  \r\n\r\n    OBS: 'var' em escopo global ou escopo de função\r\n    - Se 'var' for declarado fora de qualquer função, é considerada uma *variável global*;\r\n    - Se declarado dentro de uma função, é considerada uma *variável local* à função.\r\n\r\n",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-2",
            "name": "",
            "value": "#### Aula 18 - Tipos de dados primitivos",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-3",
            "name": "",
            "value": "- Ao declarar uma variável não tipada e não atribuída, o JS pressupõe que o tipo desta variável é 'undefined', ou seja, **não aponta pra local nenhum na memória**.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-4",
            "name": "",
            "value": "let nome\r\nreturn typeof nome",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-5",
            "name": "",
            "value": "- Ao declarar uma variável do tipo *null*, ela **também não aponta pra nenhum local na memória**.\r\n- Geralmente ao atribuir *null* para uma variável, esperamos que ela seja reatribuída para algum valor posteriormente.\r\n- Quando eu defino uma variável *null*, eu informo ao JS que eu especificamente não quero que ela aponte pra algum local na memória.\r\n- **É possível** atribuir *undefined* como o tipo de uma variável, mas o correto ao desejar que esta variável não aponte pra nenhum local na memória é utilizar o *null*.\r\n- *null* é do tipo *object*, enquanto *undefined* é do tipo *undefined*.\r\n- *null* não é atribuído por default.\r\n- o JS usa *undefined* para indicar propriedades ou variáveis inexistentes, como no exemplo:",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-6",
            "name": "",
            "value": "let obj = {}\r\nreturn obj.nome // undefined\r\n",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-7",
            "name": "",
            "value": "    ATENÇÃO ÀS VERIFICAÇÕES LÓGICAS:",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-8",
            "name": "",
            "value": "let a; // undefined\r\nlet b = null; // null\r\n\r\nreturn(a == b); // true (porque ambos são \"falsy\")\r\nreturn(a === b); // false (porque `undefined` !== `null`)\r\n",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-9",
            "name": "",
            "value": "    Problemas com 'JSON.stringify'\r\n- Se um objeto tiver propriedades *undefined*, elas são **removidas** ao converter para JSON, enquanto null é mantido.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-10",
            "name": "",
            "value": "let obj = { nome: undefined, idade: null };\r\nreturn (JSON.stringify(obj)); // {\"idade\":null}",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-11",
            "name": "",
            "value": "Quando precisamos que um valor \"vazio\" seja mantido em JSON ou ao manipular APIs, devemos usar *null*.  \r\n\r\n    Tipos de dados primitivos:\r\n- String\r\n- Number\r\n- Undefined\r\n- Null\r\n- Boolean\r\n- Symbol",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-0",
            "name": "",
            "value": "#### Aula 20",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-1",
            "name": "",
            "value": "    Operadoradores aritiméticos:  \r\n\r\n- Adição: +\r\n- Subtração: -\r\n- Multiplicação: *\r\n- Divisão: /\r\n- Potênciação: **\r\n- Resto da divisão: %  \r\n\r\n\r\n    Operadoradores de incremento:  \r\n\r\n- Incrementa em um: ++\r\n- Descrescenta em um: --  \r\n\r\nOBS: operadores de incremento podem ser posicionados à frente ou atrás da variável. A diferença é que se à frete o contador primeiro soma e depois referencia, e atrás, primeiro referencia e depois soma.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-2",
            "name": "",
            "value": "let contador =0\r\nreturn contador++",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-3",
            "name": "",
            "value": "let contador =0\r\nreturn ++contador",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-4",
            "name": "",
            "value": "    Operadores de atribuição composta  \r\n- contador+=passo -> contador = contador+passo\r\n- contador-=passo -> contador = contador-passo\r\n- contador*=passo -> contador = contador*passo\r\n- contador/=passo -> contador = contador/passo\r\n- contador%=passo -> contador = contador%passo\r\n- contador**=passo -> contador = contador**passo",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-5",
            "name": "",
            "value": "OBS: em alguns casos, quando o primeiro elemento da operação aritimética for do tipo número e um segundo elemento for do tipo string mas uma string de números, o JS converte o segundo elemento e efetua a operação.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-6",
            "name": "",
            "value": "- parseInt(variavel): converte uma string em um número inteiro (ou seja, também faz truncamento)\r\n- parseFloat(variavel): converte mantendo as casas decimais  \r\n\r\nAmbas as funções tem as seguintes características em comum:\r\n- ignoram espaços em branco no início",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-7",
            "name": "",
            "value": "let exemplo = \"  32\"\r\nreturn parseInt(exemplo)",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-8",
            "name": "",
            "value": "- Lêem até encontrar um caractere inválido:",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-9",
            "name": "",
            "value": "let exemplo = \"3.14abc\"\r\nreturn parseFloat(exemplo)",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-10",
            "name": "",
            "value": "- Retornam NaN caso a string não comece com um número",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-11",
            "name": "",
            "value": "let exemplo = \"abc123\"\r\nreturn parseInt(exemplo)",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-12",
            "name": "",
            "value": "- Aceitam notação científica (e ou E)",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-13",
            "name": "",
            "value": "let exemplo = \"2.5e3\"\r\nreturn parseInt(exemplo)",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-14",
            "name": "",
            "value": "let exemplo = \"2.5e3\"\r\nreturn parseFloat(exemplo)",
            "mode": "javascript",
            "outputs": []
        },
        {
            "id": "tmp-15",
            "name": "",
            "value": "    OBS: Função Number()  \r\nA função Number() em JavaScript é usada para converter um valor para o tipo numérico. Diferente de parseInt() e parseFloat(), que analisam strings parcialmente, Number() tenta converter a string inteira em um número ou retorna NaN se a conversão falhar.  \r\nQuando usar?  \r\n- Quando tem certeza que o valor é um número válido\r\n- Para converter valores booleanos (true converte para 1 e false converte para 0) e null (converte para 0).\r\n- Evite usar para strings misturadas com texto, pois retorna NaN.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-16",
            "name": "",
            "value": "    Em Resumo:  \r\n- Number() é mais rigoroso e falha se encontrar caracteres inválidos;\r\n- parseInt() e parseFloat() são mais tolerantes e tentam extrair números de strings;\r\n- Use Number() quando quiser conversões diretas e sem ambiguidades.\r\n",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-17",
            "name": "",
            "value": "#### Aula 21 - métodos alert, confirm e prompt",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-18",
            "name": "",
            "value": "- *alert()* na verdade é uma função que está dentro do objeto *window*. Quando usamos apenas *alert()*, na verdade isto é um atalho para *window.alert()*. Retorna 'undefined'.\r\n- tudo que está dentro do objeto *window* está relacionado à *janela do navegador*.\r\n- *window.confirm('mensagem')*: exibe uma mensagem de confirmação, com um botão de ok e um de cancelar. retorna 'true' ou 'false'.\r\n- *window.prompt('mensagem')*: pede entrada de dados com botões 'cancelar' e 'ok' e printa mensagem contida nos parênteses. Retorna a entrada.\r\n",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-19",
            "name": "",
            "value": "    OBS: Se uma 'função' está fora de um objeto ela é *de fato* uma função, enquanto se ela estiver dentro de um objeto, é considerada um **método**.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-20",
            "name": "",
            "value": "- Pode-se atribuir os resultados destes métodos à variáveis, que, depois da criação, quando chamadas, retornam o resultado da função.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-21",
            "name": "",
            "value": "    OBS: por algum motivo, se eu peço let variavel = prompt('mensagem'), apesar de armazenar a variável, o retorno é undefined.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-22",
            "name": "",
            "value": "- Por default, o a tipagem da variável recebida através de prompt é string.\r\n- Para converter a entrada para número, pode-se usar qualquer uma das funções de conversão (parseInt, parseFloat ou Number)\r\n- Strings do tipo `${string}`são chamadas de *template strings*.",
            "mode": "md",
            "outputs": []
        },
        {
            "id": "tmp-23",
            "name": "",
            "value": "",
            "mode": "md",
            "outputs": []
        }
    ]
}